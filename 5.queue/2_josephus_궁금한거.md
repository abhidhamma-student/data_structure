
선형큐를 만들고 동작시켰는데 오류가 났어
그런데 enqueue의 매개변수에 &를 빼니까 잘 동작해 이유가 뭘까?

---
`Enqueue` 함수에서 매개변수인 `const T& item`을 사용할 때 `&`를 제거하고 `const T item` 으로 변경하는 것이 동작에 영향을 미친다는 것은 주목할 만한 사항입니다. 이 문제는 주로 참조로 전달된 객체가 임시 객체일 경우 발생할 수 있습니다. 여기서 발생할 수 있는 주요 문제는 두 가지입니다:

1. **임시 객체의 참조 문제**: `Enqueue`에 전달된 객체가 임시 객체일 경우 (예를 들어, `q.Enqueue(Queue<int>::Front());` 처럼 `Front`로부터 바로 반환된 값), `Enqueue` 함수 내부에서 사용되는 시점에 이미 해당 임시 객체가 소멸되어 있을 가능성이 있습니다. 이는 참조가 가리키는 메모리 주소가 더 이상 유효하지 않은 값을 가리킬 수 있음을 의미합니다.

2. **객체 복사의 차이**: `const T& item`이 `Enqueue` 함수로 참조로 전달될 때, 원본 객체의 상태에 따라 함수 내에서 사용되는 `item`의 상태에 영향을 받을 수 있습니다. 만약 원본 객체가 함수 호출 도중 변경되거나 소멸된다면, 참조를 통해 접근하는 `item` 값도 영향을 받을 수 있습니다. 예를 들어, 큐에서 원소를 꺼내면서 동시에 그 원소를 다시 큐에 추가하는 경우 (재정렬이나 로테이션 작업 등) 원본 데이터의 무결성이 보장되지 않을 수 있습니다.

`&`를 제거하고 값을 직접 복사하여 전달하게 되면, 이러한 참조 관련 문제를 피할 수 있습니다. 값 복사는 원본 객체의 복사본을 만들기 때문에, 원본 객체가 수정되거나 소멸되더라도 `Enqueue` 함수에 전달된 복사본은 안전하게 보존됩니다. 이는 특히 멀티스레드 환경이나 복잡한 데이터 처리 로직에서 객체의 생명주기를 관리하는 것이 어려울 때 유용합니다.

따라서, 참조를 제거하고 값으로 전달하면 함수 호출 시마다 전달된 객체의 복사본을 생성하여 사용하므로, 참조로 인해 발생할 수 있는 안정성 문제를 해결할 수 있습니다. 이는 성능 저하를 일으킬 수 있는 복사 비용을 수반하지만, 프로그램의 안정성과 정확성을 높이는 대가로 볼 수 있습니다.